= CUD File Format Strategy

The CUD file format is JSON file that represents Graph Entities (Nodes/Relationships) and how to manage them in terms of **C**reate/**U**pdate/**D**elete operations.

You can configure the topic in the following way:

[source,json,subs="verbatim,attributes"]
----
"neo4j.cud.topics": "<COMMA_SEPARATED_LIST_OF_TOPICS>"
----

[source,json,subs="attributes"]
----
"neo4j.cud.topics": "my-topic,my-other.topic"
----

We have two formats:

* `Node`
* `Relationship`

== Node

Node JSON format has a set of fields which contain the operation (`create`, `update`, `merge` and `delete`), label information and node properties.

Let us describe the fields:

[#table_cud_node_fields]
.CUD file **Node format** fields description
[cols="3",opts=header]
|===

| field
| mandatory
| Description

| op
| yes
| The operation type: create/merge/update/delete

*N.B.* delete messages are for **individual nodes** itâ€™s not intended to be a generic way of doing cypher query building from JSON

| properties
| no, in case the operation is `delete`, otherwise yes
| The properties attached to the node

| ids
| no, in case the operation is `create`, otherwise yes
| In case the operation is merge/update/delete this field is **mandatory** and contains
the primary/unique keys of the node that will be used to do the lookup to the entity.
In case you use as key the `_id` name the cud format will refer to Neo4j's node internal for the node lookup.

*N.B.* If you'll use the `_id` reference with the op `merge` it will work as simple update, this means that if the node
with the passed internal id does not exist, it will not be created.

| labels
| no
| The labels attached to the node.

*N.B.* Neo4j allows to create nodes without labels, but from a performance perspective, it's a bad idea don't provide them.

| type
| yes
| The entity type: node/relationship => node in this case

| detach
| no
| In case the operation is "delete", you can specify if perform a https://neo4j.com/docs/cypher-manual/current/clauses/delete/["detach" delete] that means delete any incident relationships when you delete a node

*N.B.* if no value is provided, the default is `false`

|===

=== Examples

* An example of a `CREATE` operation;

[source,json]
----
{
  "type": "node",
  "op": "create",
  "labels": ["Foo", "Bar"],
  "properties": {
    "id": 1,
    "foo": "foo-value"
  }
}
----

which would be transformed into the following Cypher query:

[source,cypher]
----
CREATE (n:Foo:Bar) SET n = $properties
----

* An example of a `UPDATE` operation;

[source,json]
----
{
  "type": "node",
  "op": "update",
  "labels": ["Foo", "Bar"],
  "ids": {
    "id": 0
  },
  "properties": {
    "id": 1,
    "foo": "foo-value"
  }
}
----

which would be transformed into the following Cypher query:

[source,cypher]
----
MATCH (n:Foo:Bar {id: $ids.id}) SET n += $properties
----

* An example of a `MERGE` operation;

[source,json]
----
{
  "type": "node",
  "op": "merge",
  "labels": ["Foo", "Bar"],
  "ids": {
    "id": 0
  },
  "properties": {
    "id": 1,
    "foo": "foo-value"
  }
}
----

which would be transformed into the following Cypher query:

[source,cypher]
----
MERGE (n:Foo:Bar {id: $ids.id}) SET n += $properties
----

* An example of a `DELETE` operation;

[source,json]
----
{
  "type": "NODE",
  "op": "delete",
  "labels": ["Foo", "Bar"],
  "ids": {
    "id": 0
  }
}
----

which would be transformed into the following Cypher query:

[source,cypher]
----
MATCH (n:Foo:Bar {id: $ids.id}) DELETE n
----

* An example of a `DELETE` operation with detach `true`;

[source,json]
----
{
  "type": "NODE",
  "op": "delete",
  "labels": ["Foo", "Bar"],
  "ids": {
    "id": 0
  },
  "detach": true
}
----

which would be transformed into the following Cypher query:

[source,cypher]
----
MATCH (n:Foo:Bar {id: $ids.id}) DETACH DELETE n
----

== Relationship

Relationship JSON format has a set of fields which contain the operation (`create`, `update`, `merge` and `delete`), relationship type information, source and target node objects and relationship properties.

Let us describe the fields:

[#table_cud_rels_fields]
.CUD file **Relationship format** fields description
[cols="3",opts=header]
|===
| field
| mandatory
| Description

| op
| yes
| The operation type: create/merge/update/delete

| properties
| no, in case the operation is `delete`, otherwise yes
| The properties attached to the relationship

| rel_type
| yes
| The relationship type

|ids
|no
|Contains the primary/unique keys of the relationship that will be used to look up to the entity

| from
| yes, if you use the `_id` field reference into `ids` you can leave labels blank
| Contains the info about the source node of the relationship.`op` field can only be `merge` and `match` and by default it's `match`.
For the description of the `ids` and `labels` fields, please look at the node fields description above.


| to
| yes, if you use the `_id` field reference into `ids` you can leave labels blank
| Contains the info about the target node of the relationship.`op` field can only be `merge` and `match` and by default it's `match`.
For the description of the `ids` and `labels` fields, please look at the node fields description above

| type
| yes
| The entity type: `node`/`relationship` => `relationship` in this case

|===

=== Examples

* An example of a `CREATE` operation;

[source,json]
----
{
  "type": "relationship",
  "op": "create",
  "rel_type": "RELATED_TO",
  "from": {
    "labels": ["Foo"],
    "ids": {
      "id": 0
    }
  },
  "to": {
    "labels": ["Bar"],
    "ids": {
      "id": 1
    }
  },
  "properties": {
    "by": "incident"
  }
}
----

which would be transformed into the following Cypher query:

[source,cypher]
----
MATCH (start:Foo {id: $from.ids.id}) WITH start
MATCH (end:Bar {id: $to.ids.id}) WITH start, end
CREATE (start)-[r:RELATED_TO]->(end)
SET r = $properties
----

* An example of a `CREATE` operation with `merging` the source node;

[source,json]
----
{
  "type": "relationship",
  "op": "create",
  "rel_type": "RELATED_TO",
  "from": {
    "labels": ["Foo"],
    "ids": {
      "id": 0
    },
    "op": "merge"
  },
  "to": {
    "labels": ["Bar"],
    "ids": {
      "id": 1
    },
    "op": "match"
  },
  "properties": {
    "by": "incident"
  }
}
----

which would be transformed into the following Cypher query:

[source,cypher]
----
MERGE (start:Foo {id: $from.ids.id}) WITH start
MATCH (end:Bar {id: $to.ids.id}) WITH start, end
CREATE (start)-[r:RELATED_TO]->(end)
SET r = $properties
----

* An example of a `UPDATE` operation;

[source,json]
----
{
  "type": "relationship",
  "op": "update",
  "rel_type": "RELATED_TO",
  "from": {
    "labels": ["Foo"],
    "ids": {
      "id": 0
    }
  },
  "to": {
    "labels": ["Bar"],
    "ids": {
      "id": 1
    },
    "op": "merge"
  },
  "properties": {
    "by": "incident"
  }
}
----

which would be transformed into the following Cypher query:

[source,cypher]
----
MATCH (start:Foo {id: $from.ids.id}) WITH start
MERGE (end:Bar {id: $to.ids.id}) WITH start, end
MATCH (start)-[r:RELATED_TO]->(end)
SET r += $properties
----

* An example of a `UPDATE` operation with `relationship ids`;

[source,json]
----
{
  "type": "relationship",
  "op": "update",
  "rel_type": "RELATED_TO",
  "from": {
    "labels": ["Foo"],
    "ids": {
      "id": 0
    }
  },
  "to": {
    "labels": ["Bar"],
    "ids": {
      "id": 1
    },
    "op": "merge"
  },
  "ids": {
    "id": 5
  },
  "properties": {
    "by": "incident"
  }
}
----

which would be transformed into the following Cypher query:

[source,cypher]
----
MATCH (start:Foo {id: $from.ids.id}) WITH start
MERGE (end:Bar {id: $to.ids.id}) WITH start, end
MATCH (start)-[r:RELATED_TO {id: $ids.id}]->(end)
SET r += $properties
----

* An example of a `MERGE` operation;

[source,json]
----
{
  "type": "relationship",
  "op": "merge",
  "rel_type": "RELATED_TO",
  "from": {
    "labels": ["Foo"],
    "ids": {
      "id": 0
    }
  },
  "to": {
    "labels": ["Bar"],
    "ids": {
      "id": 1
    },
    "op": "merge"
  },
  "properties": {
    "by": "incident"
  }
}
----

which would be transformed into the following Cypher query:

[source,cypher]
----
MATCH (start:Foo {id: $from.ids.id}) WITH start
MERGE (end:Bar {id: $to.ids.id}) WITH start, end
MERGE (start)-[r:RELATED_TO]->(end)
SET r += $properties
----

* An example of a `MERGE` operation with `relationship ids`;

[source,json]
----
{
  "type": "relationship",
  "op": "MERGE",
  "rel_type": "RELATED_TO",
  "from": {
    "labels": ["Foo"],
    "ids": {
      "id": 0
    }
  },
  "to": {
    "labels": ["Bar"],
    "ids": {
      "id": 1
    },
    "op": "merge"
  },
  "ids": {
    "id": 5
  },
  "properties": {
    "by": "incident"
  }
}
----

which would be transformed into the following Cypher query:

[source,cypher]
----
MATCH (start:Foo {id: $from.ids.id}) WITH start
MERGE (end:Bar {id: to.ids.id}) WITH start, end
MERGE (start)-[r:RELATED_TO {id: $ids.id}]->(end)
SET r += $properties
----

* An example of a `DELETE` operation;

[source,json]
----
{
  "type": "relationship",
  "op": "delete",
  "rel_type": "RELATED_TO",
  "from": {
    "labels": ["Foo"],
    "ids": {
      "id": 0
    }
  },
  "to": {
    "labels": ["Bar"],
    "ids": {
      "id": 1
    }
  }
}
----

which would be transformed into the following Cypher query:

[source,cypher]
----
MATCH (start:Foo {id: $from.ids.id}) WITH start
MATCH (end:Bar {id: $to.ids.id}) WITH start, end
MATCH (start)-[r:RELATED_TO]->(end)
DELETE r
----

* An example of a `DELETE` operation with `relationship ids`;

[source,json]
----
{
  "type": "relationship",
  "op": "DELETE",
  "rel_type": "RELATED_TO",
  "from": {
    "labels": ["Foo"],
    "ids": {
      "id": 0
    }
  },
  "to": {
    "labels": ["Bar"],
    "ids": {
      "id": 1
    }
  },
  "ids": {
    "id": 5
  }
}
----

which would be transformed into the following Cypher query:

[source,cypher]
----
MATCH (start:Foo {id: $from.ids.id}) WITH start
MATCH (end:Bar {id: $to.ids.id}) WITH start, end
MATCH (start)-[r:RELATED_TO {id: $ids.id}]->(end)
DELETE r
----