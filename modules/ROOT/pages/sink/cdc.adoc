= Change Data Capture Strategy

This strategy allows to ingest CDC events coming from another Neo4j instance, generated either by a source connector instance configured for xref:#kafka-connect-source-cdc-strategy[Change Data Capture strategy] or the deprecated neo4j streams plugin.

[IMPORTANT]
Change Data Capture events needs to be generated by the same corresponding version of the Source connector, which must be configured using a value converter that supports schemas.

Two sub-strategies are available:

* The <<source-id, Source ID>> strategy merges nodes and relationships by the CDC event's `elementId` or `id` fields (internal Neo4j entity identifier).

* The <<schema, Schema>> strategy merges nodes and relationships by the constraints (node key, relationship key and/or property uniqueness + existence) defined in the source database.

[#source-id]
== Source ID sub-strategy

`Source ID` strategy merges nodes and relationships by the source entity's `elementId` or `id` values, by storing this value as an explicit property on the target nodes and relationships and by marking nodes with an explicit label.

Configuration of this strategy requires declaration of list of topics to read change events from, and optional label name to be used as a marker and also the property name to store the `elementId` or `id` values of the source entities.

[source,json,subs="verbatim,attributes"]
----
"neo4j.cdc.source-id.topics": "<comma-separated list of topics>"
"neo4j.cdc.source-id.label-name": "<the label attached to the node, default=SourceEvent>"
"neo4j.cdc.source-id.property-name": "<the property name given to the CDC id field, default=sourceId>"
----

=== Example

Given that you configure the topics your sink connector subscribes to as follows;

[source,json]
----
"topics": "topic.1,topic.2"
----

You need to declare that you want to use `cdc.source-id` strategy by providing the list of topics you want to consume change events from.

[source,json,subs="verbatim,attributes"]
----
"neo4j.cdc.source-id.topics": "topic.1,topic.2"
----

Each change event will then be projected into a graph entity.

Consider this node creation event:

[.tabbed-example]
====
[.include-with-CDC-message]
=====
ifdef::backend-pdf[]
.node.created.cdc.json
endif::[]
[source,json]
----
include::example$producer-data/node.created.cdc.json[]
----
=====

[.include-with-Streams-change-message]
=====
ifdef::backend-pdf[]
.node.created.streams.json
endif::[]
[source,json]
----
include::example$producer-data/node.created.streams.json[]
----
=====

====

The node is persisted as follows, with the sink connector using the `elementId` or `id` fields of the node change event to create or update the node.

[.tabbed-example]
====
[.include-with-CDC-message]
=====
ifdef::backend-pdf[]
.CDC event
endif::[]
[source,cypher]
----
(:Person:SourceEvent {first_name: "John", last_name: "Doe", email: "john.doe@example.com", sourceId: "4:741ce592-19fc-4a39-bf9c-6c38d568f0a5:0"}
----
=====

[.include-with-Streams-change-message]
=====
ifdef::backend-pdf[]
.Streams event
endif::[]
[source,cypher]
----
(:Person:SourceEvent {first_name: "John", last_name: "Doe", email: "john.doe@example.com", sourceId: "1004"})
----
=====

====

Consider this relationship creation event:

[.tabbed-example]
====
[.include-with-CDC-message]
=====
ifdef::backend-pdf[]
.relationship.created.cdc.json
endif::[]
[source,json]
----
include::example$producer-data/relationship.created.cdc.json[]
----
=====

[.include-with-Streams-change-message]
=====
ifdef::backend-pdf[]
.relationship.created.streams.json
endif::[]
[source,json]
----
include::example$producer-data/relationship.created.streams.json[]
----
=====

====

The relationship is persisted as follows, with the sink connector using the `elementId` or `id` fields of the start and end nodes from the change event to create or update the relationship.

[.tabbed-example]
====
[.include-with-CDC-message]
=====
ifdef::backend-pdf[]
.CDC event
endif::[]
[source,cypher]
----
(:Person:SourceEvent {last_name: "Doe", first_name: "John", sourceId: "4:741ce592-19fc-4a39-bf9c-6c38d568f0a5:0"})-[:KNOWS {since: "2012-01-01", sourceId: "5:741ce592-19fc-4a39-bf9c-6c38d568f0a5:0"}]->(:Person:SourceEvent {last_name: "Doe", first_name: "Mary", sourceId: "4:741ce592-19fc-4a39-bf9c-6c38d568f0a5:1"})
----
=====

[.include-with-Streams-change-message]
=====
ifdef::backend-pdf[]
.Streams event
endif::[]
[source,cypher]
----
(:Person:SourceEvent {last_name: "Doe", first_name: "John", sourceId: "123"})-[:KNOWS {since: "2012-01-01", sourceId: "123"}]->(:Person:SourceEvent {last_name: "Doe", first_name: "Mary", sourceId: "456"})
----
=====

====

[#schema]
== Schema sub-strategy

`Schema` strategy merges nodes and relationships by the constraints declared in the change event, thus preserves the source schema structure.

Configuration of this strategy requires declaration of list of topics to read change events from.

[source,json,subs="verbatim,attributes"]
----
"neo4j.cdc.schema.topics": "<COMMA_SEPARATED_LIST_OF_TOPICS>"
----

=== Example

Given that you configure the topics your sink connector subscribes to as follows;

[source,json]
----
"topics": "topic.1,topic.2"
----

You need to declare that you want to use `cdc.schema` strategy by providing the list of topics you want to consume change events from.

[source,json,subs="verbatim,attributes"]
----
"neo4j.cdc.schema.topics": "topic.1,topic.2"
----

Each change event will then be projected into a graph entity.

Consider this node creation event:

[.tabbed-example]
====
[.include-with-CDC-message]
=====
ifdef::backend-pdf[]
.node.created.cdc.json
endif::[]
[source,json]
----
include::example$producer-data/node.created.cdc.json[]
----
=====

[.include-with-Streams-change-message]
=====
ifdef::backend-pdf[]
.node.created.streams.json
endif::[]
[source,json]
----
include::example$producer-data/node.created.streams.json[]
----
=====

====

The relationship is persisted as follows, with the sink connector using the `keys` or `schema` fields in order to insert/update the nodes, without a need for extra properties or labels.

[.tabbed-example]
====
[.include-with-CDC-message]
=====
ifdef::backend-pdf[]
.CDC event
endif::[]
[source,cypher]
----
(:Person {first_name: "John", last_name: "Doe", email: "john.doe@example.com"}
----
=====

[.include-with-Streams-change-message]
=====
ifdef::backend-pdf[]
.Streams event
endif::[]
[source,cypher]
----
(:Person {first_name: "John", last_name: "Doe", email: "john.doe@example.com"})
----
=====

====

Consider this relationship creation event:

[.tabbed-example]
====
[.include-with-CDC-message]
=====
ifdef::backend-pdf[]
.relationship.created.cdc.json
endif::[]
[source,json]
----
include::example$producer-data/relationship.created.cdc.json[]
----
=====

[.include-with-Streams-change-message]
=====
ifdef::backend-pdf[]
.relationship.created.streams.json
endif::[]
[source,json]
----
include::example$producer-data/relationship.created.streams.json[]
----
=====

====

The relationship is persisted as follows, with the sink connector using the `keys` fields of the start and end nodes from the change event to create or update the relationship, again without a need for extra properties or labels.

[.tabbed-example]
====
[.include-with-CDC-message]
=====
ifdef::backend-pdf[]
.CDC event
endif::[]
[source,cypher]
----
(:Person {last_name: "Doe", first_name: "John"})-[:KNOWS {since: "2012-01-01"}]->(:Person {last_name: "Doe", first_name: "Mary"})
----
=====

[.include-with-Streams-change-message]
=====
ifdef::backend-pdf[]
.Streams event
endif::[]
[source,cypher]
----
(:Person {last_name: "Doe", first_name: "John"})-[:KNOWS {since: "2012-01-01"}]->(:Person {last_name: "Doe", first_name: "Mary"})
----
=====

====

