=== The Pattern strategy

This strategy allows you to extract nodes and relationships from a JSON object through extraction patterns.

==== Node Patterns

Node patterns are defined similar to Cypher node patterns.

. start with `(`
. define optional list of labels, separated by `:`, such as `:Person` or `:Person:Employee`
. open property section with `{`
. define properties to be treated as keys, each prepended with `!`, where at least one key property needs to be provided
. either
.. nothing or `*`, meaning that assign all properties from JSON object to the node
.. list of property names to be assigned to the node from JSON object
.. list of property names _not_ to be assigned to the node, each prepended with `-`, all other properties from JSON object will be assigned to the node
. close property section with `}`
. end with `)`

[NOTE]
You cannot mix inclusion and exclusion so your pattern must contains all exclusion or inclusion properties.

===== Examples

* `MERGE` operation on `User` label with `userId` treated as a key and assigning all properties from JSON object to the node
+
[source]
----
(:User{!userId})
----
+
or
+
[source]
----
(:User{!userId, *})
----

* `MERGE` operation on `User` label with `userId` treated as a key and assigning *only* `surname` property from JSON object to the node
+
[source]
----
(:User{!userId, surname})
----

* `MERGE` operation on `User` label with `userId` treated as a key and assigning *only* `surname` and `address.city` properties from JSON object to the node
+
[source]
----
(:User{!userId, surname, address.city})
----

* `MERGE` operation on `User` label with `userId` treated as key and assigning all properties excluding `address` property from JSON object to the node
+
[source]
----
(:User{!userId, -address})
----

===== Configuration

You can configure the node pattern as follows;

[source,json,subs="verbatim,attributes"]
----
"neo4j.topic.pattern.node.<TOPIC_NAME>": "<NODE_PATTERN>"
----

For instance, given the following `json` published via the `user` topic:

[source,json]
----
{"userId": 1, "name": "Andrea", "surname": "Santurbano", "address": {"city": "Venice", "cap": "30100"}}
----

You can transform it into a node by providing the following configuration:

[source,json,subs="verbatim,attributes"]
----
"neo4j.topic.pattern.node.user": "(:User{!userId})"
----

==== Relationship Patterns

Relationship patterns are defined similar to Cypher relationship patterns.

. node pattern for start node
. `-[`
. define relationship type, prepended by `:`, such as `:BOUGHT` or `:KNOWS`
. open property section with `{`
. either
.. nothing or `*`, meaning that assign all properties from JSON object to the node
.. list of property names to be assigned to the node from JSON object
.. list of property names _not_ to be assigned to the node, each prepended with `-`, all other properties from JSON object will be assigned to the node
. close property section with `}`
. `]\->`
. node pattern for end node

[NOTE]
You cannot mix inclusion and exclusion so your pattern must contains all exclusion or inclusion properties.

===== Examples

. `MERGE` operation on `User` and `Product` labels with `userId` and `productId` treated as keys respectively and `MERGE` a `BOUGHT` relationship between them assigning all other JSON properties to the relationship
+
[source]
----
(:User{!userId})-[:BOUGHT]->(:Product{!productId})
----

. `MERGE` operation on `User` and `Product` labels with `userId` and `productId` treated as keys respectively and `MERGE` a `BOUGHT` relationship between them assigning *only* `price` and `currency` properties from JSON object to the relationship
+
[source]
----
(:User{!userId})-[:BOUGHT{price,currency}]->(:Product{!productId})
----

. `MERGE` operation on `User` and `Product` labels with `userId` and `productId` treated as keys respectively and `MERGE` a `BOUGHT` relationship between them assigning *only* `price`,  `currency` and `shippingAddress.city` properties from JSON object to the relationship
+
[source]
----
(:User{!userId})-[:BOUGHT{price,currency,shippingAddress.city}]->(:Product{!productId})
----

. `MERGE` operation on `User` and `Product` labels with `userId` and `productId` treated as keys respectively and `MERGE` a `BOUGHT` relationship between them assigning all properties *excluding* `shippingAddress` from JSON object to the relationship
+
[source]
----
(:User{!userId})-[:BOUGHT{-shippingAddress}]->(:Product{!productId})
----

. `MERGE` operation on `User` and `Product` labels with `userId` and `productId` treated as keys respectively, assign `userFirstName` and `userLastName` properties from JSON object to the `User` node and `MERGE` a `BOUGHT` relationship between them assigning *only* `price` and `currency` properties from JSON object to the relationship
+
[source]
----
(:User{!userId, userFirstName, userLastName})-[:BOUGHT{price, currency}]->(:Product{!productId})
----

===== Configuration

You can configure the relationship pattern as follows;

[source,json,subs="verbatim,attributes"]
----
"neo4j.topic.pattern.relationship.<TOPIC_NAME>": "<RELATIONSHIP_PATTERN>"
----

For instance, given the following `json` published via the `user` topic:

[source,json]
----
{"userId": 1, "productId": 100, "price": 10, "currency": "â‚¬", "shippingAddress": {"city": "Venice", cap: "30100"}}
----

You can transform it into a path, like `(n)-[r]->(m)`, by providing the following configuration:

[source,json,subs="verbatim,attributes"]
----
"neo4j.topic.pattern.relationship.user": "(:User{!userId})-[:BOUGHT{price, currency}]->(:Product{!productId})"
----

==== Tombstone Records

The pattern strategy supports https://en.wikipedia.org/wiki/Tombstone_(data_store)[tombstone records].
In order to use it, message key should contain at least the key properties present in the provided pattern and message value should be set as `null`.

[IMPORTANT]
**Currently you can't define multiple patterns for a single topic, such as extracting more than one node or relationship type from a single message.
In order to achieve this, you have to use a different topic for each pattern.**
